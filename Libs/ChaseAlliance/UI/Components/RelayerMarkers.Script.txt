#Include "ChaseAlliance/Libs/Common/UI/Manialink.Script.txt" as Manialink
#Include "ChaseAlliance/Libs/Common/UI/Consts/Align.Script.txt" as Align
#Include "ChaseAlliance/Libs/ChaseAlliance/Consts/Colors.Script.txt" as Colors
#Include "ChaseAlliance/Libs/Common/UI/Components/Common.Script.txt" as Common

#Include "TextLib" as TL

#Const C "RelayerMarkers"

#Const C_Circle """image="file://Media/Painter/Stencils/01-EllipseRound/Brush.tga" """
#Const C_Arrow """image="file://Media/Painter/Stencils/05-Triangle0/Brush.tga" """

Text _Model (){
	return """
<framemodel id="{{{C}}}" class="{{{C}}}">
	<frame id="visibility" hidden="1"><!-- this is needed because the c++ will force the framemodel to be always visible  -->
		<quad id="background" size="3 3" opacity="0.9" {{{Align::CC}}} {{{C_Circle}}}/>
		<frame id="arrow-pivot">
			<quad id="arrow-head" pos="0 1.5" size="3 2" opacity="0.9" {{{Align::CB}}} {{{C_Arrow}}} />
		</frame>
	</frame>
</framemodel>
""";
}

Text _Directives(){
	return """//!
#Struct K_{{{C}}}{
	CMlFrame Root;
	CMlQuad Background;
	CMlFrame ArrowPivot;
	CMlQuad ArrowHead;
	CMlFrame Visibility;
}
""";
}

Text _Functions(){
	return """//!

K_{{{C}}} {{{C}}}_Get(CMlFrame _Parent,Text _Id) {
	declare CMlFrame Root <=> (_Parent.GetFirstChild(_Id) as CMlFrame);
	declare CMlQuad Background <=> (Root.GetFirstChild("background") as CMlQuad);
	declare CMlFrame ArrowPivot <=> (Root.GetFirstChild("arrow-pivot") as CMlFrame);
	declare CMlQuad ArrowHead <=> (Root.GetFirstChild("arrow-head") as CMlQuad);
	declare CMlFrame Visibility <=> (Root.GetFirstChild("visibility") as CMlFrame);

	return K_{{{C}}}{
		Root = Root,
		Visibility = Visibility,
		Background = Background,
		ArrowPivot = ArrowPivot,
		ArrowHead = ArrowHead
	};
}

Void {{{C}}}_UpdateVisibility(K_{{{C}}} _RelayerMarker,CUIConfigMarker _Marker,CSmPlayer _Relayer){

	declare CSmPlayer Player <=> GetPlayer(_Marker.ImageUrl);
	if(GUIPlayer == Null || Player == Null || _Relayer == Null || Player != _Relayer){
		_RelayerMarker.Visibility.Hide();
		return;
	}
	if(_Relayer.CurrentClan == 1 || _Relayer.CurrentClan == 2){
		if(GUIPlayer.CurrentClan == _Relayer.CurrentClan){
			_RelayerMarker.Visibility.Show();
			_RelayerMarker.Background.ModulateColor = Teams[GUIPlayer.CurrentClan - 1].ColorUI;
			_RelayerMarker.ArrowHead.ModulateColor = Teams[GUIPlayer.CurrentClan - 1].ColorUI;
			return;
		}
	}
	_RelayerMarker.Visibility.Hide();
}

Void {{{C}}}_Update(K_{{{C}}} _RelayerMarker, CSmPlayer _Relayer){

	if(_Relayer == Null || GUIPlayer == Null)return;
	declare Vec2 BgAbsPos = _RelayerMarker.Background.AbsolutePosition_V3;
	if(BgAbsPos.X > -124 && BgAbsPos.X < 124 && BgAbsPos.Y > -68 && BgAbsPos.Y < 68){
		_RelayerMarker.ArrowPivot.Hide();
	}else{
		_RelayerMarker.ArrowPivot.Show();
		declare Vec3 PlayerPos = GUIPlayer.Position;
		declare Vec3 TargetPos = _Relayer.Position;
		declare Vec3 PlayerForward = GUIPlayer.AimDirection;//for this aim dir should be enough ML::CrossProduct(_Player.LeftDirection, _Player.UpDirection);
		declare Vec3 TargetRelativePos = TargetPos-PlayerPos;
		_RelayerMarker.ArrowPivot.RelativeRotation = ML::RadToDeg(ML::OrientedAngle(TargetRelativePos,PlayerForward));
	}
			
}
""";
}

declare Boolean G_Loaded;
Void Unload() {
	G_Loaded = False;
}

Void Load() {
	if(G_Loaded)return;
	Unload();
	G_Loaded = True;
	Manialink::Load();
	Common::Load();
	Manialink::CreateComponent(C,["GetPlayer"],_Model(),_Directives(),_Functions(),"");
}
