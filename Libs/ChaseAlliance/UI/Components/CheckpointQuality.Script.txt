#Include "ChaseAlliance/Libs/Common/UI/Manialink.Script.txt" as Manialink
#Include "ChaseAlliance/Libs/Common/UI/Consts/Align.Script.txt" as Align
#Include "MathLib" as ML
#Include "TimeLib" as TIL

#Const C "CheckpointQuality"


Text _Model (){
	return """
<framemodel id="{{{C}}}" {{{Align::CC}}}>
    <label id="checkpoint-quality-label" textfont="RajdhaniMono" textsize="12" {{{Align::LC}}}/>
</framemodel>""";
}

Text _Directives(){
	return """//!
#Struct K_{{{C}}}{
    CMlFrame Root;
	CMlLabel CheckpointQualityLabel;
}
""";
}


Text _Labels(){
	return """//!
***Init***
***
declare Real LastSuccessCpSpeed = 0.; 
declare Integer QualityMessageStartTime = TIL::GetMillisecondsSinceInit (); 
***
""";
}

Text _Functions(){
	return """//!
K_{{{C}}} {{{C}}}_Get(CMlFrame _Parent,Text _Id) {
	declare CMlFrame Root <=> (_Parent.GetFirstChild(_Id) as CMlFrame);
	declare CMlLabel CheckpointQualityLabel <=> (Root.GetFirstChild("checkpoint-quality-label") as CMlLabel);
	return K_{{{C}}}{
		Root = Root,
		CheckpointQualityLabel = CheckpointQualityLabel
	};
}

Real CalculateRelayQuality(Integer _PlayerCpTime, Integer _RelayerCpTime, Real _PlayerCpSeeed, Real _RelayerCpSpeed){
	declare Real TimeDelta = (ML::ToReal(_PlayerCpTime) - ML::ToReal(_RelayerCpTime))/1000;
	declare Real RelativeSpeedDelta = ML::Clamp((_PlayerCpSeeed - _RelayerCpSpeed)/_RelayerCpSpeed, -2., 2.);
	declare Real RelayQuality = ML::Max(0., ML::Min(10000., 10000*ML::Exp(-2*TimeDelta)*(0.85 + RelativeSpeedDelta)));
	return RelayQuality;
}

Text RelayQualityToString(Real _RelayQuality){
	if (_RelayQuality < 2000)
		return "Ok";
	if (_RelayQuality < 7000)
		return "Good";
	if (_RelayQuality < 9000)
		return "Very Good";
	if (_RelayQuality < 1000)
		return "Excelent";
	return "Legendary";
}
Real {{{C}}}_Update(K_{{{C}}} _CheckpointQualityLabel,CSmPlayer _Player, CSmPlayer _Relayer, CSmPlayer _PrevRelayer, Integer _CurrentCp, Integer _LastSuccessRelayCpTime, Boolean _PrevRelayWasSuccess, Real _LastSuccessCpSpeed, Integer _QualityMessageStartTime){
	
	declare Integer ElapsedTimeSinceLastQualityMessage = TIL::GetMillisecondsSinceInit () - _QualityMessageStartTime;

	declare Real LastSuccessCpSpeedReturn = _LastSuccessCpSpeed;
	if (_LastSuccessCpSpeed == 0 && _Relayer != Null && _Relayer.RaceWaypointTimes.count > _CurrentCp){
		LastSuccessCpSpeedReturn = _Relayer.Speed;
		
	}
	
	// _CheckpointQualityLabel.CheckpointQualityLabel.Value = ""^ElapsedTimeSinceLastQualityMessage;

	if(_Player != Null && _PrevRelayer != Null && _PrevRelayer != _Player && _PrevRelayWasSuccess ){
		
		if (_Player.RaceWaypointTimes.count >= 1){
			// _CheckpointQualityLabel.CheckpointQualityLabel.Value = ""^_Player.RaceWaypointTimes[_Player.RaceWaypointTimes.count - 1]^" "^_LastSuccessRelayCpTime;
	// 		// _CheckpointQualityLabel.CheckpointQualityLabel.Value = ""^CalculateRelayQuality(_Player.RaceWaypointTimes[_Player.RaceWaypointTimes.count - 1], _CurrentCpTime, 0., 0.);
			if 	(ElapsedTimeSinceLastQualityMessage > 0 && ElapsedTimeSinceLastQualityMessage < 2900){
				if (_CheckpointQualityLabel.CheckpointQualityLabel.Value == ""){
					declare Real RelayQuality = CalculateRelayQuality(_Player.RaceWaypointTimes[_Player.RaceWaypointTimes.count - 1], _LastSuccessRelayCpTime, _Player.Speed, _PrevRelayer.Speed);
					declare Text RelayQualityText = RelayQualityToString(RelayQuality);
					_CheckpointQualityLabel.CheckpointQualityLabel.Value = ""^RelayQualityText^" "^RelayQuality;
				}
			}else{
				_CheckpointQualityLabel.CheckpointQualityLabel.Value = "";
			}
	
		}
	}
	
	if (_LastSuccessCpSpeed != 0 && _Relayer != Null && _Relayer.RaceWaypointTimes.count == _CurrentCp){
		LastSuccessCpSpeedReturn = _Relayer.Speed;
	}

	return LastSuccessCpSpeedReturn;
}


Integer {{{C}}}_UpdateMessageTimout(K_{{{C}}} _CheckpointQualityLabel,CSmPlayer _Player, Integer _CpCrossCount,Integer _QualityMessageStartTime){
	
	declare Integer _QualityMessageStartTimeReturn = _QualityMessageStartTime;
	if(_Player != Null && _CpCrossCount == 1){
		_QualityMessageStartTimeReturn = TIL::GetMillisecondsSinceInit ();
	}
	return _QualityMessageStartTimeReturn;	
}
""";
}

declare Boolean G_Loaded;
Void Unload() {
	G_Loaded = False;
}

Void Load() {
	if(G_Loaded)return;
	Unload();
	G_Loaded = True;
	Manialink::Load();
	Manialink::CreateComponent(C,[],_Model(),_Directives(),_Functions(),_Labels());
}
