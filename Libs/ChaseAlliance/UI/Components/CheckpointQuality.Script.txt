#Include "ChaseAlliance/Libs/Common/UI/Manialink.Script.txt" as Manialink
#Include "ChaseAlliance/Libs/Common/UI/Consts/Align.Script.txt" as Align
#Include "MathLib" as ML
#Include "TimeLib" as TIL


#Const C "CheckpointQuality"


Text _Model (){
	return """
<framemodel id="{{{C}}}" {{{Align::CC}}}>
	<quad size="30 6" bluramount="500" bgcolor="333333" opacity="0.6" {{{Align::CC}}} />
    <label size="30 6" id="checkpoint-quality-label" textfont="RajdhaniMono" textsize="2.5" {{{Align::CC}}}/>
</framemodel>""";
}

Text _Directives(){
	return """//!
#Struct K_{{{C}}}{
    CMlFrame Root;
	CMlLabel CheckpointQualityLabel;
}
""";
}


Text _Labels(){
	return """//!
***Init***
***
declare Real LastSuccessCpSpeed = 0.; 
declare Integer QualityMessageStartTime = TIL::GetMillisecondsSinceInit (); 
***
""";
}

Text _Functions(){
	return """//!
K_{{{C}}} {{{C}}}_Get(CMlFrame _Parent,Text _Id) {
	declare CMlFrame Root <=> (_Parent.GetFirstChild(_Id) as CMlFrame);
	declare CMlLabel CheckpointQualityLabel <=> (Root.GetFirstChild("checkpoint-quality-label") as CMlLabel);
	return K_{{{C}}}{
		Root = Root,
		CheckpointQualityLabel = CheckpointQualityLabel
	};
}

Real CalculateRelayQuality(Integer _PlayerCpTime, Integer _RelayerCpTime, Real _PlayerCpSeeed, Real _RelayerCpSpeed){
	declare Real TimeDelta = (ML::ToReal(_PlayerCpTime) - ML::ToReal(_RelayerCpTime))/1000;
	declare Real RelativeSpeedDelta = ML::Clamp((_PlayerCpSeeed - _RelayerCpSpeed)/_RelayerCpSpeed, -2., 2.);
	declare Real RelayQuality = ML::Max(0., ML::Min(10000., 10000*ML::Exp(-2*TimeDelta)*(0.85 + RelativeSpeedDelta)));
	return RelayQuality;
}

Text RelayQualityToString(Real _RelayQuality){
	declare Integer maxPoint = 10069;
	if (_RelayQuality < ML::NearestInteger(0.15*maxPoint))
		return "$888Good";
	if (_RelayQuality < ML::NearestInteger(0.8*maxPoint))
		return "$dd5Nice";
	if (_RelayQuality < ML::NearestInteger(1.0*maxPoint))
		return "$fe0$sExcelent";
	return "$91eLegendary";
}
Real {{{C}}}_Update(K_{{{C}}} _CheckpointQualityLabel,CSmPlayer _Player, CSmPlayer _Relayer, CSmPlayer _PrevRelayer, Integer _CurrentCp, Integer _LastSuccessRelayCpTime, Boolean _PrevRelayWasSuccess, Real _LastSuccessCpSpeed, Integer _QualityMessageStartTime){
	_CheckpointQualityLabel.Root.Visible = False;
	declare Integer ElapsedTimeSinceLastQualityMessage = TIL::GetMillisecondsSinceInit () - _QualityMessageStartTime;

	declare Real LastSuccessCpSpeedReturn = _LastSuccessCpSpeed;
	if (_LastSuccessCpSpeed == 0 && _Relayer != Null && _Relayer.RaceWaypointTimes.count > _CurrentCp){
		LastSuccessCpSpeedReturn = _Relayer.Speed;
		
	}
	
	// _CheckpointQualityLabel.CheckpointQualityLabel.Value = ""^ElapsedTimeSinceLastQualityMessage;

	if(_Player != Null && _PrevRelayer != Null && _PrevRelayer != _Player && _PrevRelayWasSuccess ){
		
		if (_Player.RaceWaypointTimes.count >= 1){
			// _CheckpointQualityLabel.CheckpointQualityLabel.Value = ""^_Player.RaceWaypointTimes[_Player.RaceWaypointTimes.count - 1]^" "^_LastSuccessRelayCpTime;
	// 		// _CheckpointQualityLabel.CheckpointQualityLabel.Value = ""^CalculateRelayQuality(_Player.RaceWaypointTimes[_Player.RaceWaypointTimes.count - 1], _CurrentCpTime, 0., 0.);
			if 	(ElapsedTimeSinceLastQualityMessage > 0 && ElapsedTimeSinceLastQualityMessage < 2900){
				_CheckpointQualityLabel.Root.Visible = True;
				if (_CheckpointQualityLabel.CheckpointQualityLabel.Value == ""){
					declare Real RelayQuality = CalculateRelayQuality(_Player.RaceWaypointTimes[_Player.RaceWaypointTimes.count - 1], _LastSuccessRelayCpTime, _Player.Speed, _PrevRelayer.Speed);
					declare Text RelayQualityText = RelayQualityToString(RelayQuality);
					_CheckpointQualityLabel.CheckpointQualityLabel.Value = "$s"^ML::NearestInteger(RelayQuality)^" PTS | "^RelayQualityText;
				}
			}else{
				_CheckpointQualityLabel.CheckpointQualityLabel.Value = "";
			}
	
		}
	}
	
	if (_LastSuccessCpSpeed != 0 && _Relayer != Null && _Relayer.RaceWaypointTimes.count == _CurrentCp){
		LastSuccessCpSpeedReturn = _Relayer.Speed;
	}

	return LastSuccessCpSpeedReturn;
}


Integer {{{C}}}_UpdateMessageTimout(K_{{{C}}} _CheckpointQualityLabel,CSmPlayer _Player, Integer _CpCrossCount,Integer _QualityMessageStartTime){
	
	declare Integer _QualityMessageStartTimeReturn = _QualityMessageStartTime;
	if(_Player != Null && _CpCrossCount == 1){
		_QualityMessageStartTimeReturn = TIL::GetMillisecondsSinceInit ();
	}
	return _QualityMessageStartTimeReturn;	
}
""";
}

declare Boolean G_Loaded;
Void Unload() {
	G_Loaded = False;
}

Void Load() {
	if(G_Loaded)return;
	Unload();
	G_Loaded = True;
	Manialink::Load();
	Manialink::CreateComponent(C,[],_Model(),_Directives(),_Functions(),_Labels());
}
