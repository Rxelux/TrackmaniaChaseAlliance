//#RequireContext CSmMode
#Extends "ChaseAlliance/Libs/ModeBase/GameLoop.Script.txt"
#Const CompatibleMapTypes "TrackMania\\TM_Race"

#Include "ChaseAlliance/Libs/Common/Log.Script.txt"
#Include "ChaseAlliance/Libs/Common/Env.Script.txt" as Env
#Include "ChaseAlliance/Libs/Common/Commands.Script.txt" as Commands
#Include "ChaseAlliance/Libs/Common/Users.Script.txt" as UsersL
#Include "ChaseAlliance/Libs/Common/Events.Script.txt" as Events
#Include "ChaseAlliance/Libs/Common/Messages.Script.txt" as Messages
#Include "ChaseAlliance/Libs/Common/Spawn.Script.txt" as Spawn
#Include "ChaseAlliance/Libs/Common/EndTime.Script.txt" as EndTimeL
#Include "ChaseAlliance/Libs/Common/FakeUserController.Script.txt" as Controller
#Include "ChaseAlliance/Libs/ChaseAlliance/GameState.Script.txt" as GameState
#Include "ChaseAlliance/Libs/ChaseAlliance/Players.Script.txt" as PlayersL
#Include "ChaseAlliance/Libs/ChaseAlliance/Settings.Script.txt" as Settings
#Include "ChaseAlliance/Libs/ChaseAlliance/ChaseTeams.Script.txt" as ChaseTeams
#Include "ChaseAlliance/Libs/ChaseAlliance/Markers.Script.txt" as MarkersL
#Include "ChaseAlliance/Libs/ChaseAlliance/UI/PauseUI.Script.txt" as PauseUI
#Include "ChaseAlliance/Libs/ChaseAlliance/UI/MainUI.Script.txt" as MainUI
#Include "ChaseAlliance/Libs/ChaseAlliance/UI/ScoresTableUI.Script.txt" as ScoresTableUI
#Include "ChaseAlliance/Libs/ChaseAlliance/UI/MarkersUI.Script.txt" as MarkersUI
#Include "ChaseAlliance/Libs/ChaseAlliance/Consts/Colors.Script.txt" as Colors

#Include "TextLib" as TL

#Setting S_EndRoundPause 8000 as "Pause in ms after a round"
#Setting S_EndMapPause 6000 as "Pause in ms after a map"
#Setting S_EndMatchPause 4000 as "Pause in ms after a match"

#Setting S_MapIntroDuration 8000 as "Map intro duration in ms"
#Setting S_WarmUpDuration 30000 as "Warm-up duration in ms"

#Setting S_RelayerCount 3 as "Number of players that do relays per team"
#Setting S_RelayGap 3 as "Number of failed relay a team can fall behind before getting eliminated"
#Setting S_RelaySortDelay 250 as "Cache duration in ms in order for checkpoint events to be sorted in order"
#Setting S_MapCount 3 as "Number of maps to win a match"
#Setting S_RoundCount 3 as "Number of round to win a map"
#Setting S_LapCount 5 as "Number of laps to win a round"

#Setting S_Env 0 as "0 = prod, 1 = test, 2 = dev"


***StartServer***
***
// Log("StartServer");
Commands::Load();
UsersL::Load();
Events::Load();
Messages::Load();
Spawn::Load();
Controller::Load();
GameState::Load();
PlayersL::Load();
MarkersL::Load();
Settings::Load();
ChaseTeams::Load();
PauseUI::Load();
MainUI::Load();
ScoresTableUI::Load();
MarkersUI::Load();
Commands::AddPermittedUser("pTuyJG9STcCN_11BiU3t0Q");
Commands::AddPermittedUser("V_vWwMxbQqO0GgDYtK3zTg");
Commands::AddPermittedUser("oNhUUAthQx6SkVe2YK9PXw");
***

/* ***StartScript***
***
// Log("StartScript");
*** */

***StartMatch***
***
// Log("StartMatch");
ChaseTeams::ResetTeamsMapPoint();
ChaseTeams::ToNet();
declare Integer WinningClan = 0;
***

/* ***BeforeLoadMap***
***
Log("BeforeLoadMap");
*** */

***AfterLoadMap***
***
// Log("AfterLoadMap");
Spawn::Find();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Intro;
NextYieldSleepMs = S_MapIntroDuration;
---Yield---
***

***StartMap***
***
// Log("StartMap");
ChaseTeams::ResetTeamsRoundPoint();
ChaseTeams::ToNet();
GameState::SetWarmUp();
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Manual;
***

***StartRound***
***
// Log("StartRound");
//ValidateSettings
Env::SetEnv(S_Env);
Settings::SetRelayerCount(S_RelayerCount);
Settings::SetRelayGap(S_RelayGap);
Settings::SetRelaySortDelay(S_RelaySortDelay);
Settings::SetMapCount(S_MapCount);
Settings::SetRoundCount(S_RoundCount);
Settings::SetLapCount(S_LapCount);
Settings::ToNet();
ChaseTeams::ResetTeamsRelay();
ChaseTeams::ToNet();
if(GameState::IsWarmUp()){
	Messages::SendStatus(UIManager.UIAll,"$"^TL::ColorToText(Colors::C_WarmUp)^"Warm-Up",0, CUIConfig::EUISound::Warning);
	EndTime = Now + S_WarmUpDuration;
	EndTimeL::SetEndTime(S_WarmUpDuration);
}
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;

StartTime = Now + 1500;
PlayersL::SpawnAll(StartTime);
MarkersL::RefreshMarkers();
***

***PlayLoop***
***
if(GameState::IsPlaying()){
	// ChaseTeams::PlayLoop();
	if(ChaseTeams::GetWinState() >= 0){
		GameLoop::EndRound();
	}
}
if(GameState::IsWaiting()){
	if(ChaseTeams::AreComplete()){
		// Log("Waiting -> Teams are complete");
		GameLoop::EndRound();
	}
}
if(!GameState::IsPlaying()){
	foreach(Player in Players){
		if(Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned){
			PlayersL::Spawn(Player,Now+1500);
		}
	}
}
if(GameState::IsWarmUp() && Now > EndTime){
	if(ChaseTeams::AreComplete()){
		GameState::SetPlaying();
		Messages::SendStatus(UIManager.UIAll,"Starting Round!",S_EndRoundPause,CUIConfig::EUISound::Warning);
	}
	GameLoop::EndRound();
}
***

***EndRound***
***
// Log("EndRound");
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
WinningClan = ChaseTeams::GetWinClan();
if(WinningClan > 0){
	Messages::ClearAll();
	ChaseTeams::IncrementTeamRoundPoint(WinningClan);
	Messages::SendStatus(UIManager.UIAll,ChaseTeams::GetWinStateString(),S_EndRoundPause,CUIConfig::EUISound::Warning);
	Log(Teams[WinningClan-1].Name^" wins the round: "^ChaseTeams::GetWinStateString(),True);
	Messages::SendBig(UIManager.UIAll,"$"^TL::ColorToText(Teams[WinningClan-1].ColorUI)^Teams[WinningClan-1].Name^" wins the round." ,S_EndRoundPause,CUIConfig::EUISound::VictoryPoint );
	if(ChaseTeams::GetTeamRoundPoint(WinningClan) >= Settings::GetRoundCount()){
		ChaseTeams::IncrementTeamMapPoint(WinningClan);
		GameLoop::EndMap();
	}
	ChaseTeams::ToNet();
	Log(Teams[0].Name^": Rounds "^ChaseTeams::GetTeamRoundPoint(1)^"/"^Settings::GetRoundCount()^"\n"^Teams[1].Name^": Rounds "^ChaseTeams::GetTeamRoundPoint(2)^"/"^Settings::GetRoundCount(),True);
}

if(GameState::IsWaiting() && ChaseTeams::AreComplete()){
	GameState::SetPlaying();
	Messages::SendStatus(UIManager.UIAll,"Starting Round!",S_EndRoundPause,CUIConfig::EUISound::Warning);
}
EndTimeL::SetEndTime(S_EndRoundPause);
NextYieldSleepMs = S_EndRoundPause;
---Yield---

if(GameState::IsWarmUp() || GameState::IsPlaying() && !ChaseTeams::AreComplete()){
	GameState::SetWaiting();
	Messages::SendStatus(UIManager.UIAll,"$"^TL::ColorToText(Colors::C_Waiting)^"Waiting for players",0, CUIConfig::EUISound::Warning);
}
***

***EndMap***
***
// Log("EndMap");
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
if(WinningClan > 0){
	Log(Teams[WinningClan-1].Name^" wins the map.",True);
	Messages::SendBig(UIManager.UIAll,"$"^TL::ColorToText(Teams[WinningClan-1].ColorUI)^Teams[WinningClan-1].Name^" wins the map." ,S_EndMapPause,CUIConfig::EUISound::EndRound);
	if(ChaseTeams::GetTeamMapPoint(WinningClan) >= Settings::GetMapCount()){
		GameLoop::EndMatch();
		Log(Teams[0].Name^": Maps "^ChaseTeams::GetTeamMapPoint(1)^"/"^Settings::GetMapCount()^"\n"^Teams[1].Name^": Maps "^ChaseTeams::GetTeamMapPoint(2)^"/"^Settings::GetMapCount(),True);
	}
}
// declare netwrite Text Net_Race_LoadingScreen_ImageUrl for Teams[0] = "https://wallpapercave.com/wp/pXzF4fB.jpg";
// Net_Race_LoadingScreen_ImageUrl = "https://wallpapercave.com/wp/pXzF4fB.jpg";
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
NextYieldSleepMs = S_EndMapPause;
---Yield---
***
	
***EndMatch***
***
Log("EndMatch");
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
if(WinningClan > 0){
	Log(Teams[WinningClan-1].Name^" wins the match.",True);
	Messages::SendBig(UIManager.UIAll,"$"^TL::ColorToText(Teams[WinningClan-1].ColorUI)^Teams[WinningClan-1].Name^" wins the match." ,S_EndMatchPause,CUIConfig::EUISound::EndMatch);
}
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Manual;
NextYieldSleepMs = S_EndMatchPause;
---Yield---
***

/* ***BeforeUnloadMap***
***
Log("BeforeUnloadMap");
*** */

/* ***AfterUnloadMap***
***
Log("AfterUnloadMap");
*** */

/* ***EndScript***
***
Log("EndScript");
*** */

***BeforeYield***
***
foreach (Event in UIManager.PendingEvents) {
	Commands::PassUIEvent(Event);
	Controller::PassUIEvent(Event);
	PlayersL::PassUIEvent(Event);
}
foreach (Event in PendingEvents){
	Commands::PassModeEvent(Event);
	ChaseTeams::PassModeEvent(Event);
	PlayersL::PassModeEvent(Event);
	MarkersL::PassModeEvent(Event);
}
foreach (EventTime => Events in Events::GetPendingSorted()) {
	ChaseTeams::PassLibSortedEvent(EventTime,Events);
}
foreach (Event in Events::GetPending()) {
	GameLoop::PassLibEvent(Event);
	UsersL::PassLibEvent(Event);
	Controller::PassLibEvent(Event);
	Settings::PassLibEvent(Event);
	if(Event.Source == Commands::C_EventSource){
		if(Event.Name == "Pause"){
			if(GameState::IsPause()){
				Log("Match resume",True);
				GameState::SetWaiting();
				Messages::ClearAll();
				Messages::SendStatus(UIManager.UIAll,"$"^TL::ColorToText(Colors::C_Waiting)^"Waiting for players",0, CUIConfig::EUISound::Warning);
			}else{
				GameState::SetPause();
				Messages::ClearAll();
				Log("Match is Paused",True);
				Messages::SendBig(UIManager.UIAll,"$"^TL::ColorToText(Colors::C_Pause)^"Pause",0,CUIConfig::EUISound::EndRound);
				GameLoop::EndRound();
			}
		}
	}
}
Controller::Yield();
Messages::Yield();
ChaseTeams::Yield();
***